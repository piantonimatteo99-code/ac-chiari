/**
 * This ruleset is designed around a family-centric data model.
 * A "Famiglia" is identified by a unique address and contains members.
 * Access is primarily granted to the head of the household (capofamiglia).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isAdmin() {
      return isSignedIn() && getUserData().roles.hasAny(['admin']);
    }

    function isCapofamiglia(famigliaId) {
       return isSignedIn() && request.auth.uid == get(/databases/$(database)/documents/famiglie/$(famigliaId)).data.uidCapofamiglia;
    }

    // ----------------------------------------------------------------------
    // User Profile Rules
    // ----------------------------------------------------------------------
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow update: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      // Disallow delete for data integrity.
      allow delete: if false;
    }

    // ----------------------------------------------------------------------
    // Family Rules
    // ----------------------------------------------------------------------
    match /famiglie/{famigliaId} {
      allow get: if isCapofamiglia(famigliaId) || isAdmin();
      allow list: if isAdmin();
      
      allow write: if isSignedIn() && request.resource.data.uidCapofamiglia == request.auth.uid;
      
      allow delete: if false;
      
      match /membri/{membroId} {
        // canAccessParentFamily checks if the user trying to access the subcollection
        // is the same one who would be allowed to write the parent document.
        // This works even if the parent document does not exist yet (on create).
        function canWriteParentFamily() {
          // On create, the parent doc doesn't exist. We check against the incoming data.
          let isCreating = resource == null;
          if (isCreating) {
            // Can't check incoming parent doc data, so we rely on other rules.
            // This is tricky. Let's assume for creation, we check the incoming member data if possible,
            // but for now, we simplify. The main `write` on parent collection is the gatekeeper.
            // A simpler rule for write: if you are the capofamiglia of the PARENT document.
             return isCapofamiglia(famigliaId);
          }
          // On update/delete, the parent doc exists.
          return isCapofamiglia(famigliaId);
        }

        // Allow list/read to admins OR the head of the specific family.
        allow list, read: if isAdmin() || isCapofamiglia(famigliaId);
        // Allow write/delete only to the head of the family.
        allow write, delete: if isCapofamiglia(famigliaId);
      }
    }
  }
}
